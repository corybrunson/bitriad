% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/triad-census-an.r
\name{triad_census_an}
\alias{triad_census_an}
\alias{triad.census.an}
\alias{triad_census_batagelj_mrvar}
\alias{triad_census_batagelj_mrvar_alt}
\alias{triad_census_projection}
\title{Triad census for affiliation networks}
\usage{
triad_census_an(bigraph, method = "batagelj_mrvar", ..., add.names = FALSE)

triad.census.an(bigraph, method = "batagelj_mrvar", ..., add.names = FALSE)

triad_census_batagelj_mrvar(bigraph)

triad_census_batagelj_mrvar_alt(bigraph, actors = NULL, max_weight = NULL)

triad_census_projection(bigraph, verbose = FALSE)
}
\arguments{
\item{bigraph}{An affiliation network.}

\item{method}{Character; the triad census method to use. Currently only 
\code{"batagelj_mrvar"} is implemented. \code{"projection"} calls an 
inefficient but reliable implementation in R from the first package version
that invokes the \code{\link{simple_triad_census}} of the
\code{\link{actor_projection}} of \code{bigraph}.}

\item{...}{Additional arguments passed to the \code{method} function.}

\item{add.names}{Logical; whether to label the rows and columns of the output
matrix.}

\item{actors}{Numeric vector of \code{bigraph} actor node IDs (\strong{to 
expedite the C++ function; to be obviated by a self-contained 
implementation}).}

\item{max_weight}{Numeric; maximum number of events shared by two actors of 
\code{bigraph} (\strong{to expedite the C++ function; to be obviated by a 
self-contained implementation}).}

\item{verbose}{Logical; whether to display progress bars.}
}
\value{
A matrix counts of triad congruence classes, with row indices 
  reflecting pairwise exclusive events and column indices reflecting 
  triadwise events.
}
\description{
Given an affiliation network, tally all actor triads by 
  isomorphism class.
}
\details{
The \code{triad_census_*} functions implement the four triad
  censuses described below in matrix form.


}
\section{Triad censuses}{
 The function \code{\link{triad_census_an}} computes 
  the full triad census for an affiliation network. The functions 
  \code{\link{unif_triad_census}} and \code{\link{str_triad_census}} compute 
  the more compact uniformity and structural triad censuses, respectively, 
  using similar methods. The function \code{\link{simple_triad_census}} 
  computes the classical (undirected) triad census for the actor projection 
  of an affiliation network, using \code{\link[igraph]{triad_census}} but, if
  the result doesn't make sense (i.e. the sum of the entries is not the 
  number of triples of nodes), then it instead uses its own, much slower 
  method. Each of these censuses can be projected from the previous using the
  function \code{\link{project_census}}.
}

\examples{
data(women_clique)
(tc <- triad_census_an(women_clique, add.names = TRUE))
sum(tc) == choose(vcount(actor_projection(women_clique)), 3)
}
