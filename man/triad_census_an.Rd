% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/triad-census-an.r
\name{triad_census_an}
\alias{triad_census_an}
\alias{triad.census.an}
\alias{triad_census_full}
\alias{triad_census_batagelj_mrvar}
\alias{triad_census_batagelj_mrvar_alt}
\alias{triad_census_projection}
\alias{triad_census_binary}
\alias{triad_census_binary_batagelj_mrvar}
\alias{triad_census_binary_projection}
\alias{str_triad_census}
\alias{structural.triad.census}
\title{Triad census for affiliation networks}
\usage{
triad_census_an(bigraph, census = "full", method = "batagelj_mrvar", ...,
  add.names = FALSE)

triad.census.an(bigraph, census = "full", method = "batagelj_mrvar", ...,
  add.names = FALSE)

triad_census_full(bigraph, method = "batagelj_mrvar", ...,
  add.names = FALSE)

triad_census_batagelj_mrvar(bigraph)

triad_census_batagelj_mrvar_alt(bigraph, actors = NULL, max_weight = NULL)

triad_census_projection(bigraph, verbose = FALSE)

triad_census_binary(bigraph, method = "batagelj_mrvar", ...,
  add.names = FALSE)

triad_census_binary_batagelj_mrvar(bigraph)

triad_census_binary_projection(bigraph, verbose = FALSE)

str_triad_census(bigraph, method = "batagelj_mrvar", ..., add.names = FALSE)

structural.triad.census(bigraph, method = "batagelj_mrvar", ...,
  add.names = FALSE)
}
\arguments{
\item{bigraph}{An affiliation network.}

\item{census}{Character; the type of triad census to calculate, either
\code{"full"} or \code{"binary"} (also called \emph{structural}).}

\item{method}{Character; the triad census method to use. Currently only 
\code{"batagelj_mrvar"} is implemented. \code{"projection"} calls an 
inefficient but reliable implementation in R from the first package version
that invokes the \code{\link{simple_triad_census}} of the
\code{\link{actor_projection}} of \code{bigraph}.}

\item{...}{Additional arguments passed to the \code{method} function.}

\item{add.names}{Logical; whether to label the rows and columns of the output
matrix.}

\item{actors}{Numeric vector of \code{bigraph} actor node IDs (\strong{to 
expedite the C++ function; to be obviated by a self-contained 
implementation}).}

\item{max_weight}{Numeric; maximum number of events shared by two actors of 
\code{bigraph} (\strong{to expedite the C++ function; to be obviated by a 
self-contained implementation}).}

\item{verbose}{Logical; whether to display progress bars.}
}
\value{
A matrix counts of triad congruence classes, with row indices 
  reflecting pairwise exclusive events and column indices reflecting 
  triadwise events.
}
\description{
Given an affiliation network, tally all actor triads by 
  isomorphism class.
}
\details{
The \code{triad_census_*} functions implement the four triad
  censuses described below in matrix form.


}
\section{Triad censuses}{
 Three triad censuses are implemented for affiliation 
  networks:
  \itemize{
  \item The \emph{full triad census} (Brunson, 2015) records the number of 
  triads of each isomorphism class. The classes are indexed by a partition, 
  \eqn{\lambda=(\lambda_1\leq\lambda_2\leq\lambda_3)}, indicating the number 
  of events attended by both actors in each pair but not the third, and a 
  positive integer, \eqn{w}, indicating the number of events attended by all 
  three actors. The isomorphism classes are organized into a matrix with rows
  indexed by \eqn{\lambda} and columns indexed by \eqn{w}, with the 
  partitions \eqn{\lambda} ordered according to the \emph{revolving door
  ordering} (Kreher & Stinson, 1999). The main function
  \code{\link{triad_census_an}} defaults to this census.
  \item In the context of sparse affiliation networks, the full triad census 
  may be less useful than information on how many triads are connected by at 
  least one event in each distinct way. Conceptually, a congruence relation 
  can be defined on the set of triads that considers any two triads congruent
  if each corresponding pair of actors both attended or did not attend at 
  least one event not attended by the third, and if the corresponding triads 
  both attended or did not attend at least one event together. The 
  \emph{binary triad census} (Brunson, 2015; therein called the
  \emph{structural triad census}) records the number of triads in each
  congruence class.
  \item The \emph{simple triad census} is just the traditional 4-entry triad 
  census on the netwok projected onto the actor nodes. The function 
  \code{\link{simple_triad_census}} computes the classical (undirected) triad
  census for the actor projection of an affiliation network, using 
  \code{\link[igraph]{triad_census}}; if the result doesn't make sense (i.e.,
  the sum of the entries is not the number of triples of nodes), then it 
  instead uses its own, much slower method.
  }
  Each of these censuses can be projected from the previous using the 
  function \code{\link{project_census}}. A fourth census, called the 
  \emph{uniformity triad census} and implemented as 
  \code{\link{unif_triad_census}}, is deprecated. Three-actor triad 
  affiliation networks can be constructed and plotted using the 
  \code{\link{triad}} functions.
  
  The default method for the two affiliation network--specific triad censuses
  is adapted from the algorithm of Batagelj and Mrvar (2001).
}

\examples{
data(women_clique)
(tc <- triad_census_an(women_clique, add.names = TRUE))
sum(tc) == choose(vcount(actor_projection(women_clique)), 3)
}
\references{
Kreher, D.L., & Stinson, D.R. (1999). Combinatorial algorithms: generation, 
enumeration, and search. \emph{SIGACT News}, 30(1), 33--35.

Batagelj, V., & Mrvar, A. (2001). A subquadratic triad census algorithm for 
large sparse networks with small maximum degree. \emph{Social Networks},
23(3), 237--243.

Brunson, J.C. (2015). Triadic analysis of affiliation networks. \emph{Network
Science}, 3(4), 480--508.
}
