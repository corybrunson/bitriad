---
title: "Triadic analysis of the southern women datasets"
author: "Jason Cory Brunson"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Southern women}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r, echo = FALSE, results = 'hide', message = FALSE}
pkgs <- c('knitr', 'bitriad')
for(pkg in pkgs) library(pkg, character.only = TRUE)
opts_knit$set(progress = FALSE)
opts_chunk$set(
    echo = TRUE, message = FALSE, tidy = TRUE, warning = FALSE,
    fig.path = "figure/", fig.keep = "high", fig.width = 8,
    fig.height = 6, fig.align = "center"
)
```

This vignette applies several tools from the `bitriad` package to the study of two social groups inferred from event coattendence. The aim is to convey the meanings of the tools, and to suggest other possible applications, by illustrating their use on small and familiar data.

In their book [*Deep South*](http://books.google.com/books?id=Q3b9QTOgLFcC), five social anthropologists presented a comprehensive case study of the American caste system as it operated in a rural town in Mississippi. Among the data they collected were several tables of attendance at various events by groups of acquainted women. One of these, labeled Clique A (p. 209, Fig. 11) consists of five women, designated "Miss A" through "Miss E", and five activities, described as bridge, dinner, movies, dance, and visiting, some subset of the women participated in each of which. The attendance table is the basis for the graph object `ddggs.clique`:

```{r}
data(ddggs.clique, package = 'bitriad')
```

Since the graph is bipartite, is incidence information is contained in the incidence matrix, whose rows and columns correspond to the women and the activities, respectively.

```{r}
get.incidence(ddggs.clique)
```

To be recognized as bipartite, a graph object's nodes must have a logical `type` attribute. The tools of `bitriad` interpret the nodes of type `FALSE` as actors and those of type `TRUE` as events.

### Visualization

First let's visualize this network, arranging the nodes using the Fruchterman-Reingold algorithm:

```{r, echo = FALSE}
set.seed(10)
plot(
    ddggs.clique,
    layout = layout.fruchterman.reingold(ddggs.clique, niter = 100),
    vertex.color = ifelse(V(ddggs.clique)$type == 0, 'SkyBlue2', 'lightcoral'),
    vertex.shape = ifelse(V(ddggs.clique)$type == 0, 'circle', 'square'),
    edge.width = 2, edge.color = 'black',
    vertex.label = c(LETTERS[1:5], 1:5),
    vertex.label.family = 'sans', vertex.label.color = 'white'
)
```

The layout reveals a symmetry between the actors and the events: Exchanging Miss A and Event 2, Miss B and Event 5, and so on yields a graph isomorphism. Thus any structural information we learn about the actors in this network can be flipped into equivalent information about the events. While this equivalence is unusual, the *duality* between actors and events, which allows us to use actor-centric tools in the study of events (and vice-versa), is [of central importance](http://www.rci.rutgers.edu/~pmclean/mcleanp_01_920_313_breiger_duality.pdf) to the study of affiliation networks.

### Triad census

This social network is just large enough to exhibit a diversity of triads and just small enough to allow us to examine them in detail. Classically, the *triad census* refers to the distribution of triads of 16 isomorphism classes throughout a directed unipartite network. The women's clique is neither directed nor unipartite, but we can view a simplified (undirected) version of the triad census on its *projection*--the network of women with acquaintanceship ties inferred from their shared activities. There are only four isomorphism classes of undirected triads, distinguished by the number of edges (0 through 3) among the three nodes:

```{r}
ddggs.clique.proj <- actor.projection(ddggs.clique)
tc <- simple.triad.census(ddggs.clique.proj)
tc
```

There are no disconnected triples among the women, only three "vees" and seven "triangles". These probably exhibit some diversity of their own that is lost in the projection. To find  out, we can take a look at the **(full) triad census**. Given an affiliation network, this census tallies all triples of actors by how they coattend events--the number of "inclusive" events they all three attended and the distribution among them of "exclusive" events only attended by two. (Events only attended by one member of a triad do not serve to link them so are omitted from consideration.)

```{r}
ftc <- an.triad.census(ddggs.clique)
ftc
```

The arrangement is less intuitive than that of the simple census. The rows reflect the distribution of exclusive events, and the columns indicate the number of inclusive events; for instance, Miss A and Miss B attended two events (movies and dance) without Miss C, and Miss A and Miss C attended one event (bridge) without Miss B, while Miss B and Miss C attended no events together. Thus x=2, y=0, z=1, and w=0. The triad (A, B, C) is then labeled by the partition (2 ≥ 1 ≥ 0) (since order doesn't matter) and the count 0. The columns proceed in increasing order from 0, so this triad belongs in the first. To find the appropriate row, find the index of (2 ≥ 1 ≥ 0) in the enumeration scheme provided by the revolving door algorithm--which happens to be 5. Since this scheme begins at zero, the triad (A, B, C) is tallied in the sixth row.

We can sacrifice information about event multiplicity within triads for a simpler and more intuitive layout. This alternative is dubbed the **structural triad census** because it collapses the events to only four types, based on which actors attended them:

```{r}
stc <- ftc2stc(ftc)
stc
```

The column indicates the existence of an inclusive event; the row indicates the number of pairs of actors connected by an exclusive event (0, 1, 2, or 3). The simple triad census can also be recovered from either the full or the structural census:

```{r}
stc2tc(stc)
```

### Global clustering coefficients

The classical (global) clustering coefficient may be defined for a traditional network as the proportion of "vees" that are "closed". These vees are 2-paths, distinguished by the relative positions of the nodes (but often not by their order), and a vee is considered closed if its end nodes are tied. Since every triad of three edges counts thrice as a closed vee, we can compute the clustering coefficient of the projection directly from the simple census:

```{r}
C <- 3 * tc[4] / (tc[3] + 3 * tc[4])
C
```

The value tells us what proportion of the time two coattendees of the same woman have themselves been to an activity together. The clustering coefficient has proven a valuable single-value indicator of triadic closure--the tendency for near-connections to imply or lead to direct connections, i.e. for "friends of friends" to in fact be "friends".

The paper discusses in detail two alternative clustering coefficients specifically designed for two-mode networks. The first of these is the *[Opsahl](http://toreopsahl.com/2011/12/21/article-triadic-closure-in-two-mode-networks-redefining-the-global-and-local-clustering-coefficients/) clustering coefficient*, the first proposed measure of triadic closure specific to affiliation networks. The second is dubbed the **exclusive clustering coefficient** because it depends only on the exclusive events in any triad. Analogously to the above relationship, each of these diagnostics is recoverable from the full triad census, which is how they are calculated below. (The exclusive clustering coefficient can in fact be computed from the structural census.)

```{r}
global.c1 <- c(C = ftc2allact(ftc),
               C.opsahl = ftc2injequ(ftc),
               C.excl = ftc2indstr(ftc))
global.c1
```

### Transitivity ratios

One of the problems with the classical clustering coefficient is that it's not a good proxy for triadic closure *viewed as a process*. This is because when the three actors form a vee that later closes--what we'll call **dynamic triadic closure**--they can no longer form a vee with a different actor at the corner. Yet, while only one vee has closed, at this triad the clustering coefficient measures *three* closed vees. This has a profound effect on the value of the statistic! If instead we tally only one closed vee for every triangle in a traditional network, we obtain a statistic related to the clustering coefficient by a Möbius transformation. In the paper i suggest calling the statistic the **transitivity ratio**, and it turns out to exactly equal dynamic triadic closure when every edge of a dynamic network has its own distinct time.

The problem of getting at dynamic triadic closure in affiliation networks is more challenging, since a single event can project to several edges (and several closed vees) among the actors. In the paper i argue that the **exclusive transitivity ratio** is up to the challenge. For now, a sister network to `ddggs.clique` provides a test case. Another table of activity participation, by a different group of women in Old Town, is labeled Group I (p. 148, Table ?). This table includes fourteen women and eighteen activities:

```{r, echo = FALSE}
data(ddggs.group, package = 'bitriad')
V(ddggs.group)$label.cex <- 1 - .33 * V(ddggs.group)$type
set.seed(2)
plot(
    ddggs.group,
    #layout = layout.fruchterman.reingold(ddggs.group, niter = 100),
    layout = layout.bipartite(ddggs.group),
    vertex.color = ifelse(V(ddggs.group)$type == 0, 'SkyBlue2', 'lightcoral'),
    vertex.shape = ifelse(V(ddggs.group)$type == 0, 'circle', 'square'),
    edge.width = 2, edge.color = 'black',
    vertex.label = substr(V(ddggs.group)$name, 1,
                          ifelse(V(ddggs.group)$type, 5, 2)),
    vertex.label.family = 'sans', vertex.label.color = 'white'
)
```

Moreover, the activities all occurred in a nine-month interval, with their calendar dates included in the table, so this affiliation network is genuinely dynamic. It therefore has an explicit (global) dynamic triadic closure:

```{r}
D.ddggs.group <- dyn.triadic.closure(ddggs.group)
print(D.ddggs.group)
```

And, of the various clustering coefficients and transitivity ratios, only one closely matches this value:

```{r}
# 3 clustering coefficients, 2 transitivity ratios
```

### Local clustering coefficients

So far we have only tried to gauge transitivity tendencies in the network as a whole; that is, we have been looking at global network properties. But triadic analysis has always taken place at two levels--the micro and the macro: The Davis/Holland/Leinhardt studies tested macro network properties through their micro predictions, and the global clustering coefficient was a macro counterpart to the original (local) clustering coefficient of Watts and Strogatz. Having viewed the southern women through this global lens, we now turn to the local.

The classical local clustering coeffiicent at a node Q is the proportion of pairs of neighbors of Q who are themselves neighbors. From the images above we can see that the only pair of women not linked through at least one event are Miss B and Miss C. This means that the only local clustering coefficients we'll observe are 5/6 (for women who count Miss B and Miss C among their neighobrs) and 1 (for Miss B and Miss C). To verify, we specify the type to `local` in the base igraph function:

```{r}
local.c <- transitivity(ddggs.clique.proj, type = 'local')
local.c
```

Our two-mode-sensitive candidates are implemented using the `an.transitivity` shell with a required function that counts the open and closed wedges at each node. This "wedge function" determines the species of two-mode transitivity that will be calculated. The shell uses the wedges to compute the corresponding local or global clustering coefficient, or (if neither is specified) returns the wedge list itself.

```{r}
local.c.df <- cbind(
    C = local.c,
    C.opsahl = opsahl.transitivity(ddggs.clique, type = 'local'),
    C.excl = excl.transitivity(ddggs.clique, type = 'local')
)
rownames(local.c.df) <- V(ddggs.clique.proj)$name
local.c.df
```

As a reality check, we can test the `global` option for type of these implementations against the global values produced from the two-mode triad census.

```{r}
global.c2 <- c(
    transitivity(ddggs.clique.proj),
    opsahl.transitivity(ddggs.clique),
    excl.transitivity(ddggs.clique)
)
data.frame(From.census = global.c1, From.wedges = global.c2)
```

### Wedge-dependent local clustering

One [thoroughly documented](http://arxiv.org/abs/cond-mat/0211528) property of social networks is the inverse relationship between local connectivity and local clusterability. This relationship can be repackaged as one between the *potential* for clustering at a node Q, given by the number of 2-paths through Q (this number is k(k - 1)/2, or "k choose 2", when Q has degree k), and the *actual* clustering at Q, given as the local clustering coefficient.

The typical analysis plots the mean "degree-dependent" local clustering coefficient, taken over all nodes of a fixed degree, against the degree. The framework also prompts a question i have not yet found answered in the literature: For a fixed degree k, what does the distribution of local clustering coefficients at nodes of degree k look like? The assumption underlying the typical analysis is that the mean of this distribution is a reasonable one-variable summary of it, but the possibility exists that these distributions are skewed or otherwise asymmetric.

While Clique A is too small to draw general inferences from, it can at least provide a case study and a demonstration of these diagnostics. Since the `degree` and `transitivity` functions (the latter using the `local` value of type) are evaluated at the nodes in order of their IDs, we can match them up in a simple data frame:

```{r}
ddc <- data.frame(k = degree(ddggs.clique.proj),
                  C = transitivity(ddggs.clique.proj, type = 'local'))
print(ddc)
```

As we observed above, there is zero variability among nodes of common degree, though we can still plot the relationship between the (trivial) degree-dependent mean local clustering coefficients and the degrees:

```{r}
plot(aggregate(ddc$C, by = list(ddc$k), FUN = mean), pch = 19, type = 'b',
     main = 'Degree-dependent local clustering',
     xlab = 'Degree', ylab = 'Mean conditional local clustering coefficient')
```

Though the curve at least proceeds in the expected direction, there is little insight to be gleaned here. A more heterogeneous network is required. Fortunately for us, another, somewhat larger (but still manageable) table of women and events is available to us, labeled Group I (p. 148). The data are available [here] [1] in R format and were constructed (with one minor correction) from data at [Tore Opsahl's site] [2].

[1]: https://github.com/corybrunson/bitriad/tree/master/data
[2]: http://toreopsahl.com/datasets/#southernwomen

The visualization is quite a bit messier, but it looks like we have at least some range of degrees this time:

```{r}
ddggs.group.proj <- actor.projection(ddggs.group)
ddc2 <- data.frame(
    k = degree(ddggs.group.proj),
    C = transitivity(ddggs.group.proj, type = 'local')
)
print(ddc2)
plot(aggregate(ddc2$C, by = list(k = ddc2$k), FUN = mean),
     pch = 19, type = 'b',
     main = 'Degree-dependent local clustering',
     xlab = 'Degree', ylab = 'Mean conditional local clustering coefficient')
```

There is clearly a trade-off between the number of a woman's acquaintances (through events) and the proportion of those acquaintances that are also acquainted; perhaps one's capacity for acquaintanceship outpaces one's ability to make introductions and forge new acquaintanceships.

This distribution might be fruitfully generalized to the two-mode setting. The only chore is to come up with a suitable analog of degree--that is, a measure of local connectivity on which local clustering can be meaningfully conditioned. As suggested by the discussion above, we can adopt local wedge counts, which the `an.transitivity` function returns when neither type (local or global) is specified. Here are the wedge-dependent means and distributions using Opsahl's clustering coefficient:

```{r, warning = FALSE}
ddggs.group.wedges <- opsahl.transitivity(ddggs.group, type = '')
ddggs.group.wedges <- cbind(
    ddggs.group.wedges,
    C = ddggs.group.wedges$T / ddggs.group.wedges$V
)
plot(aggregate(ddggs.group.wedges$C,
               by = list(V = ddggs.group.wedges$V), FUN = mean),
     pch = 19, type = 'b',
     main = 'Wedge-dependent local clustering (Opsahl)',
     xlab = 'Wedges', ylab = 'Mean conditional local clustering coefficient')
```

This plot defies the consistent behavior we saw in the classical case. What, instead, if we try exclusive clustering?

```{r}
ddggs.group.wedges <- excl.transitivity(ddggs.group, type = '')
ddggs.group.wedges <- cbind(
    ddggs.group.wedges,
    C = ddggs.group.wedges$T / ddggs.group.wedges$V
)
plot(aggregate(ddggs.group.wedges$C,
               by = list(V = ddggs.group.wedges$V), FUN = mean),
     pch = 19, type = 'b',
     main = 'Wedge-dependent local clustering (exclusive)',
     xlab = 'Wedges', ylab = 'Mean conditional local clustering coefficient')
```

This plot recovers the steady, though not strictly monotonic, behavior of the classical case. In the classical case we expect local clustering coefficients to be quite large in tight-knit networks such as those produced for sociological analysis of cliques and communities; the exclusive clustering coefficient captures a more descriptive form of transitivity.

Still, however, at most two nodes share a wedge count; we will need [larger networks](http://link.springer.com/article/10.1007%2Fs11192-013-1209-z) in order to get a sense for the distributions of the wedge-conditioned local clustering coefficients. Stay tuned!
